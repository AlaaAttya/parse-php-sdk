<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

namespace Parse;

use Parse\Internal\Encodable;

/**
 * ParseACL - is used to control which users can access or modify a particular
 * object. Each ParseObject can have its own ParseACL. You can grant read and
 * write permissions separately to specific users, to groups of users that
 * belong to roles, or you can grant permissions to &quot;the public&quot; so that, for
 * example, any user could read a particular object but only a particular set
 * of users could write to that object.
 *
 * @package  Parse
 * @author   Mohamed Madbouli &lt;mohamedmadbouli@fb.com&gt;
 */
class ParseACL implements Encodable{

  /*
   * @ignore
   */
  const PUBLIC_KEY = '*';
  /**
   * @var array -
   */
  private $permissionsById = array();
  /**
   * @var bool -
   */
  private $shared = false;
  /**
   * @var ParseUser -
   */
  private static $lastCurrentUser = null;
  /**
   * @var ParseACL -
   */
  private static $defaultACLWithCurrentUser = null;
  /**
   * @var ParseACL -
   */
  private static $defaultACL = null;
  /**
   * @var bool -
   */
  private static $defaultACLUsesCurrentUser = false;

  /**
   * Create new ParseACL with read and write access for the given user.
   *
   * @param ParseUser $user
   *
   * @return ParseACL
   */
  public static function createACLWithUser($user)
  {
    $acl = new ParseACL();
    $acl-&gt;setUserReadAccess($user, true);
    $acl-&gt;setUserWriteAccess($user, true);
    return $acl;
  }

  /**
   * Create new ParseACL from existing permissions.
   *
   * @param array $data represents permissions.
   *
   * @return ParseACL
   * @throws \Exception
   * @ignore
   */
  public static function _createACLFromJSON($data)
  {
    $acl = new ParseACL();
    foreach ($data as $id =&gt; $permissions) {
      if (!is_string($id)) {
        throw new \Exception('Tried to create an ACL with an invalid userId.');
      }
      foreach ($permissions as $accessType =&gt; $value) {
        if ($accessType !== 'read' &amp;&amp; $accessType !== 'write') {
          throw new \Exception(
              'Tried to create an ACL with an invalid permission type.');
        }
        if (!is_bool($value)) {
          throw new \Exception(
              'Tried to create an ACL with an invalid permission value.');
        }
        $acl-&gt;setAccess($accessType, $id, $value);
      }
    }
    return $acl;
  }

  /**
   * Return if ParseACL shared or not.
   *
   * @return bool
   * @ignore
   */
  public function _isShared()
  {
    return $this-&gt;shared;
  }

  /**
   * Set shared for ParseACL
   *
   * @param bool $shared
   * @ignore
   */
  public function _setShared($shared)
  {
    $this-&gt;shared = $shared;
  }

  /**
   * @ignore
   */
  public function _encode()
  {
    if (empty($this-&gt;permissionsById)) {
      return new \stdClass();
    }
    return $this-&gt;permissionsById;
  }

  /**
   * Set access permission with access name, user id and if
   * the user has permission for accessing or not.
   *
   * @param string $accessType Access name.
   * @param string $userId     User id.
   * @param bool   $allowed    If user allowed to access or not.
   *
   * @throws ParseException
   */
  private function setAccess($accessType, $userId, $allowed)
  {
    if ($userId instanceof ParseUser) {
      $userId = $userId-&gt;getObjectId();
    }
    if ($userId instanceof ParseRole) {
      $userId = &quot;role:&quot; . $userId-&gt;getName();
    }
    if (!is_string($userId)) {
      throw new ParseException(
        &quot;Invalid target for access control.&quot;
      );
    }
    if (!isset($this-&gt;permissionsById[$userId])) {
      if (!$allowed) {
        return;
      }
      $this-&gt;permissionsById[$userId] = array();
    }
    if ($allowed) {
      $this-&gt;permissionsById[$userId][$accessType] = true;
    } else {
      unset($this-&gt;permissionsById[$userId][$accessType]);
      if (empty($this-&gt;permissionsById[$userId])) {
        unset($this-&gt;permissionsById[$userId]);
      }
    }
  }

  /**
   * Get if the given userId has a permission for the given access type or not.
   *
   * @param string $accessType Access name.
   * @param string $userId     User id.
   *
   * @return bool
   */
  private function getAccess($accessType, $userId)
  {
    if (!isset($this-&gt;permissionsById[$userId])) {
      return false;
    }
    if (!isset($this-&gt;permissionsById[$userId][$accessType])) {
      return false;
    }
    return $this-&gt;permissionsById[$userId][$accessType];
  }

  /**
   * Set whether the given user id is allowed to read this object.
   *
   * @param string $userId  User id.
   * @param bool   $allowed If user allowed to read or not.
   *
   * @throws \Exception
   */
  public function setReadAccess($userId, $allowed)
  {
    if (!$userId) {
      throw new \Exception(&quot;cannot setReadAccess for null userId&quot;);
    }
    $this-&gt;setAccess('read', $userId, $allowed);
  }

  /**
   * Get whether the given user id is *explicitly* allowed to read this
   * object. Even if this returns false, the user may still be able to
   * access it if getPublicReadAccess returns true or a role that the
   * user belongs to has read access.
   *
   * @param string $userId User id.
   *
   * @return bool
   *
   * @throws \Exception
   */
  public function getReadAccess($userId)
  {
    if (!$userId) {
      throw new \Exception(&quot;cannot getReadAccess for null userId&quot;);
    }
    return $this-&gt;getAccess('read', $userId);
  }

  /**
   * Set whether the given user id is allowed to write this object.
   *
   * @param string $userId  User id.
   * @param bool   $allowed If user allowed to write or not.
   *
   * @throws \Exception
   */
  public function setWriteAccess($userId, $allowed)
  {
    if (!$userId) {
      throw new \Exception(&quot;cannot setWriteAccess for null userId&quot;);
    }
    $this-&gt;setAccess('write', $userId, $allowed);
  }

  /**
   * Get whether the given user id is *explicitly* allowed to write this
   * object. Even if this returns false, the user may still be able to
   * access it if getPublicWriteAccess returns true or a role that the
   * user belongs to has write access.
   *
   * @param string $userId User id.
   *
   * @return bool
   *
   * @throws \Exception
   */
  public function getWriteAccess($userId)
  {
    if (!$userId) {
      throw new \Exception(&quot;cannot getWriteAccess for null userId&quot;);
    }
    return $this-&gt;getAccess('write', $userId);
  }


  /**
   * Set whether the public is allowed to read this object.
   *
   * @param bool $allowed
   */
  public function setPublicReadAccess($allowed)
  {
    $this-&gt;setReadAccess(self::PUBLIC_KEY, $allowed);
  }

  /**
   * Get whether the public is allowed to read this object.
   *
   * @return bool
   */
  public function getPublicReadAccess()
  {
    return $this-&gt;getReadAccess(self::PUBLIC_KEY);
  }

  /**
   * Set whether the public is allowed to write this object.
   *
   * @param bool $allowed
   */
  public function setPublicWriteAccess($allowed)
  {
    $this-&gt;setWriteAccess(self::PUBLIC_KEY, $allowed);
  }

  /**
   * Get whether the public is allowed to write this object.
   *
   * @return bool
   */
  public function getPublicWriteAccess()
  {
    return $this-&gt;getWriteAccess(self::PUBLIC_KEY);
  }

  /**
   * Set whether the given user is allowed to read this object.
   *
   * @param ParseUser $user
   * @param bool      $allowed
   *
   * @throws \Exception
   */
  public function setUserReadAccess($user, $allowed)
  {
    if (!$user-&gt;getObjectId()) {
      throw new \Exception(&quot;cannot setReadAccess for a user with null id&quot;);
    }
    $this-&gt;setReadAccess($user-&gt;getObjectId(), $allowed);
  }

  /**
   * Get whether the given user is *explicitly* allowed to read this object.
   * Even if this returns false, the user may still be able to access it if
   * getPublicReadAccess returns true or a role that the user belongs to has
   * read access.
   *
   * @param ParseUser $user
   *
   * @return bool
   *
   * @throws \Exception
   */
  public function getUserReadAccess($user)
  {
    if (!$user-&gt;getObjectId()) {
      throw new \Exception(&quot;cannot getReadAccess for a user with null id&quot;);
    }
    return $this-&gt;getReadAccess($user-&gt;getObjectId());
  }

  /**
   * Set whether the given user is allowed to write this object.
   *
   * @param ParseUser $user
   * @param bool      $allowed
   *
   * @throws \Exception
   */
  public function setUserWriteAccess($user, $allowed)
  {
    if (!$user-&gt;getObjectId()) {
      throw new \Exception(&quot;cannot setWriteAccess for a user with null id&quot;);
    }
    $this-&gt;setWriteAccess($user-&gt;getObjectId(), $allowed);
  }

  /**
   * Get whether the given user is *explicitly* allowed to write this object.
   * Even if this returns false, the user may still be able to access it if
   * getPublicWriteAccess returns true or a role that the user belongs to has
   * write access.
   *
   * @param ParseUser $user
   *
   * @return bool
   *
   * @throws \Exception
   */
  public function getUserWriteAccess($user)
  {
    if (!$user-&gt;getObjectId()) {
      throw new \Exception(&quot;cannot getWriteAccess for a user with null id&quot;);
    }
    return $this-&gt;getWriteAccess($user-&gt;getObjectId());
  }

  /**
   * Get whether users belonging to the role with the given roleName are
   * allowed to read this object. Even if this returns false, the role may
   * still be able to read it if a parent role has read access.
   *
   * @param string $roleName The name of the role.
   *
   * @return bool
   */
  public function getRoleReadAccessWithName($roleName)
  {
    return $this-&gt;getReadAccess('role:' . $roleName);
  }

  /**
   * Set whether users belonging to the role with the given roleName
   * are allowed to read this object.
   *
   * @param string $roleName The name of the role.
   *
   * @param bool   $allowed Whether the given role can read this object.
   */
  public function setRoleReadAccessWithName($roleName, $allowed)
  {
    $this-&gt;setReadAccess('role:' . $roleName, $allowed);
  }

  /**
   * Get whether users belonging to the role with the given roleName are
   * allowed to write this object. Even if this returns false, the role may
   * still be able to write it if a parent role has write access.
   *
   * @param string $roleName The name of the role.
   *
   * @return bool
   */
  public function getRoleWriteAccessWithName($roleName)
  {
    return $this-&gt;getWriteAccess('role:' . $roleName);
  }

  /**
   * Set whether users belonging to the role with the given roleName
   * are allowed to write this object.
   *
   * @param string $roleName The name of the role.
   * @param bool   $allowed  Whether the given role can write this object.
   */
  public function setRoleWriteAccessWithName($roleName, $allowed)
  {
    $this-&gt;setWriteAccess('role:' . $roleName, $allowed);
  }

  /**
   * Check whether the role is valid or not.
   *
   * @param ParseRole $role
   *
   * @throws \Exception
   */
  private static function validateRoleState($role)
  {
    if (!$role-&gt;getObjectId()) {
      throw new \Exception(
          &quot;Roles must be saved to the server before they can be used in an ACL.&quot;);
    }
  }

  /**
   * Get whether users belonging to the given role are allowed to read this
   * object. Even if this returns false, the role may still be able to read
   * it if a parent role has read access. The role must already be saved on
   * the server and its data must have been fetched in order to use this method.
   *
   * @param ParseRole $role The role to check for access.
   *
   * @return bool
   */
  public function getRoleReadAccess($role)
  {
    $this-&gt;validateRoleState($role);
    return $this-&gt;getRoleReadAccessWithName($role-&gt;getName());
  }

  /**
   * Set whether users belonging to the given role are allowed to read this
   * object. The role must already be saved on the server and its data must
   * have been fetched in order to use this method.
   *
   * @param ParseRole $role    The role to assign access.
   * @param bool      $allowed Whether the given role can read this object.
   */
  public function setRoleReadAccess($role, $allowed)
  {
    $this-&gt;validateRoleState($role);
    $this-&gt;setRoleReadAccessWithName($role-&gt;getName(), $allowed);
  }

  /**
   * Get whether users belonging to the given role are allowed to write this
   * object. Even if this returns false, the role may still be able to write
   * it if a parent role has write access. The role must already be saved on
   * the server and its data must have been fetched in order to use this method.
   *
   * @param ParseRole $role The role to check for access.
   *
   * @return bool
   */
  public function getRoleWriteAccess($role)
  {
    $this-&gt;validateRoleState($role);
    return $this-&gt;getRoleWriteAccessWithName($role-&gt;getName());
  }

  /**
   * Set whether users belonging to the given role are allowed to write this
   * object. The role must already be saved on the server and its data must
   * have been fetched in order to use this method.
   *
   * @param ParseRole $role    The role to assign access.
   * @param bool      $allowed Whether the given role can read this object.
   */
  public function setRoleWriteAccess($role, $allowed)
  {
    $this-&gt;validateRoleState($role);
    $this-&gt;setWriteAccessWithName($role-&gt;getName(), $allowed);
  }

  /**
   * Sets a default ACL that will be applied to all ParseObjects when they
   * are created.
   *
   * @param ParseACL $acl                  The ACL to use as a template for all ParseObjects
   *                                       created after setDefaultACL has been called. This
   *                                       value will be copied and used as a template for the
   *                                       creation of new ACLs, so changes to the instance
   *                                       after setDefaultACL() has been called will not be
   *                                       reflected in new ParseObjects.
   * @param bool $withAccessForCurrentUser If true, the ParseACL that is applied to
   *                                       newly-created ParseObjects will provide read
   *                                       and write access to the ParseUser#getCurrentUser()
   *                                       at the time of creation. If false, the provided
   *                                       ACL will be used without modification. If acl is
   *                                       null, this value is ignored.
   */
  public static function setDefaultACL($acl, $withAccessForCurrentUser)
  {
    self::$defaultACLWithCurrentUser = null;
    self::$lastCurrentUser = null;
    if ($acl) {
      self::$defaultACL = clone $acl;
      self::$defaultACL-&gt;_setShared(true);
      self::$defaultACLUsesCurrentUser = $withAccessForCurrentUser;
    } else {
      self::$defaultACL = null;
    }
  }

  /**
   * Get the defaultACL.
   *
   * @return ParseACL
   * @ignore
   */
  public static function _getDefaultACL()
  {
    if (self::$defaultACLUsesCurrentUser &amp;&amp; self::$defaultACL) {
      $last = self::$lastCurrentUser ? clone self::$lastCurrentUser : null;
      if (!ParseUser::getCurrentUser()) {
        return self::$defaultACL;
      }
      if ($last != ParseUser::getCurrentUser()) {
        self::$defaultACLWithCurrentUser = clone self::$defaultAC;
        self::$defaultACLWithCurrentUser-&gt;_setShared(true);
        self::$defaultACLWithCurrentUser-&gt;setUserReadAccess(ParseUser::getCurrentUser(), true);
        self::$defaultACLWithCurrentUser-&gt;setUserWriteAccess(ParseUser::getCurrentUser(), true);
        self::$lastCurrentUser = clone ParseUser::getCurrentUser();
      }
      return self::$defaultACLWithCurrentUser;
    }
    return self::$defaultACL;
  }

}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>